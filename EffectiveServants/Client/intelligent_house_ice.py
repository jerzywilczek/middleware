# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.6
#
# <auto-generated>
#
# Generated from file `intelligent_house.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module IntelligentHouse
_M_IntelligentHouse = Ice.openModule('IntelligentHouse')
__name__ = 'IntelligentHouse'

if 'NotCookingFoodCurrently' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.NotCookingFoodCurrently = Ice.createTempClass()
    class NotCookingFoodCurrently(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IntelligentHouse::NotCookingFoodCurrently'

    _M_IntelligentHouse._t_NotCookingFoodCurrently = IcePy.defineException('::IntelligentHouse::NotCookingFoodCurrently', NotCookingFoodCurrently, (), False, None, ())
    NotCookingFoodCurrently._ice_type = _M_IntelligentHouse._t_NotCookingFoodCurrently

    _M_IntelligentHouse.NotCookingFoodCurrently = NotCookingFoodCurrently
    del NotCookingFoodCurrently

_M_IntelligentHouse._t_FoodPreparer = IcePy.defineValue('::IntelligentHouse::FoodPreparer', Ice.Value, -1, (), False, True, None, ())

if 'FoodPreparerPrx' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.FoodPreparerPrx = Ice.createTempClass()
    class FoodPreparerPrx(Ice.ObjectPrx):

        def timeToPrepareFood(self, context=None):
            return _M_IntelligentHouse.FoodPreparer._op_timeToPrepareFood.invoke(self, ((), context))

        def timeToPrepareFoodAsync(self, context=None):
            return _M_IntelligentHouse.FoodPreparer._op_timeToPrepareFood.invokeAsync(self, ((), context))

        def begin_timeToPrepareFood(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.FoodPreparer._op_timeToPrepareFood.begin(self, ((), _response, _ex, _sent, context))

        def end_timeToPrepareFood(self, _r):
            return _M_IntelligentHouse.FoodPreparer._op_timeToPrepareFood.end(self, _r)

        def cookingInProgress(self, context=None):
            return _M_IntelligentHouse.FoodPreparer._op_cookingInProgress.invoke(self, ((), context))

        def cookingInProgressAsync(self, context=None):
            return _M_IntelligentHouse.FoodPreparer._op_cookingInProgress.invokeAsync(self, ((), context))

        def begin_cookingInProgress(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.FoodPreparer._op_cookingInProgress.begin(self, ((), _response, _ex, _sent, context))

        def end_cookingInProgress(self, _r):
            return _M_IntelligentHouse.FoodPreparer._op_cookingInProgress.end(self, _r)

        def timeLeftToFinishCookingFood(self, context=None):
            return _M_IntelligentHouse.FoodPreparer._op_timeLeftToFinishCookingFood.invoke(self, ((), context))

        def timeLeftToFinishCookingFoodAsync(self, context=None):
            return _M_IntelligentHouse.FoodPreparer._op_timeLeftToFinishCookingFood.invokeAsync(self, ((), context))

        def begin_timeLeftToFinishCookingFood(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.FoodPreparer._op_timeLeftToFinishCookingFood.begin(self, ((), _response, _ex, _sent, context))

        def end_timeLeftToFinishCookingFood(self, _r):
            return _M_IntelligentHouse.FoodPreparer._op_timeLeftToFinishCookingFood.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IntelligentHouse.FoodPreparerPrx.ice_checkedCast(proxy, '::IntelligentHouse::FoodPreparer', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IntelligentHouse.FoodPreparerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::FoodPreparer'
    _M_IntelligentHouse._t_FoodPreparerPrx = IcePy.defineProxy('::IntelligentHouse::FoodPreparer', FoodPreparerPrx)

    _M_IntelligentHouse.FoodPreparerPrx = FoodPreparerPrx
    del FoodPreparerPrx

    _M_IntelligentHouse.FoodPreparer = Ice.createTempClass()
    class FoodPreparer(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IntelligentHouse::FoodPreparer')

        def ice_id(self, current=None):
            return '::IntelligentHouse::FoodPreparer'

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::FoodPreparer'

        def timeToPrepareFood(self, current=None):
            raise NotImplementedError("servant method 'timeToPrepareFood' not implemented")

        def cookingInProgress(self, current=None):
            raise NotImplementedError("servant method 'cookingInProgress' not implemented")

        def timeLeftToFinishCookingFood(self, current=None):
            raise NotImplementedError("servant method 'timeLeftToFinishCookingFood' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IntelligentHouse._t_FoodPreparerDisp)

        __repr__ = __str__

    _M_IntelligentHouse._t_FoodPreparerDisp = IcePy.defineClass('::IntelligentHouse::FoodPreparer', FoodPreparer, (), None, ())
    FoodPreparer._ice_type = _M_IntelligentHouse._t_FoodPreparerDisp

    FoodPreparer._op_timeToPrepareFood = IcePy.Operation('timeToPrepareFood', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_int, False, 0), ())
    FoodPreparer._op_cookingInProgress = IcePy.Operation('cookingInProgress', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_bool, False, 0), ())
    FoodPreparer._op_timeLeftToFinishCookingFood = IcePy.Operation('timeLeftToFinishCookingFood', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_int, False, 0), (_M_IntelligentHouse._t_NotCookingFoodCurrently,))

    _M_IntelligentHouse.FoodPreparer = FoodPreparer
    del FoodPreparer

if 'CookingAlreadyInProgress' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.CookingAlreadyInProgress = Ice.createTempClass()
    class CookingAlreadyInProgress(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IntelligentHouse::CookingAlreadyInProgress'

    _M_IntelligentHouse._t_CookingAlreadyInProgress = IcePy.defineException('::IntelligentHouse::CookingAlreadyInProgress', CookingAlreadyInProgress, (), False, None, ())
    CookingAlreadyInProgress._ice_type = _M_IntelligentHouse._t_CookingAlreadyInProgress

    _M_IntelligentHouse.CookingAlreadyInProgress = CookingAlreadyInProgress
    del CookingAlreadyInProgress

_M_IntelligentHouse._t_EggsMachine = IcePy.defineValue('::IntelligentHouse::EggsMachine', Ice.Value, -1, (), False, True, None, ())

if 'EggsMachinePrx' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.EggsMachinePrx = Ice.createTempClass()
    class EggsMachinePrx(_M_IntelligentHouse.FoodPreparerPrx):

        def storedEggsAmount(self, context=None):
            return _M_IntelligentHouse.EggsMachine._op_storedEggsAmount.invoke(self, ((), context))

        def storedEggsAmountAsync(self, context=None):
            return _M_IntelligentHouse.EggsMachine._op_storedEggsAmount.invokeAsync(self, ((), context))

        def begin_storedEggsAmount(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.EggsMachine._op_storedEggsAmount.begin(self, ((), _response, _ex, _sent, context))

        def end_storedEggsAmount(self, _r):
            return _M_IntelligentHouse.EggsMachine._op_storedEggsAmount.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IntelligentHouse.EggsMachinePrx.ice_checkedCast(proxy, '::IntelligentHouse::EggsMachine', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IntelligentHouse.EggsMachinePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::EggsMachine'
    _M_IntelligentHouse._t_EggsMachinePrx = IcePy.defineProxy('::IntelligentHouse::EggsMachine', EggsMachinePrx)

    _M_IntelligentHouse.EggsMachinePrx = EggsMachinePrx
    del EggsMachinePrx

    _M_IntelligentHouse.EggsMachine = Ice.createTempClass()
    class EggsMachine(_M_IntelligentHouse.FoodPreparer):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IntelligentHouse::EggsMachine', '::IntelligentHouse::FoodPreparer')

        def ice_id(self, current=None):
            return '::IntelligentHouse::EggsMachine'

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::EggsMachine'

        def storedEggsAmount(self, current=None):
            raise NotImplementedError("servant method 'storedEggsAmount' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IntelligentHouse._t_EggsMachineDisp)

        __repr__ = __str__

    _M_IntelligentHouse._t_EggsMachineDisp = IcePy.defineClass('::IntelligentHouse::EggsMachine', EggsMachine, (), None, (_M_IntelligentHouse._t_FoodPreparerDisp,))
    EggsMachine._ice_type = _M_IntelligentHouse._t_EggsMachineDisp

    EggsMachine._op_storedEggsAmount = IcePy.Operation('storedEggsAmount', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_int, False, 0), ())

    _M_IntelligentHouse.EggsMachine = EggsMachine
    del EggsMachine

if 'NotEnoughEggsInStorage' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.NotEnoughEggsInStorage = Ice.createTempClass()
    class NotEnoughEggsInStorage(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IntelligentHouse::NotEnoughEggsInStorage'

    _M_IntelligentHouse._t_NotEnoughEggsInStorage = IcePy.defineException('::IntelligentHouse::NotEnoughEggsInStorage', NotEnoughEggsInStorage, (), False, None, ())
    NotEnoughEggsInStorage._ice_type = _M_IntelligentHouse._t_NotEnoughEggsInStorage

    _M_IntelligentHouse.NotEnoughEggsInStorage = NotEnoughEggsInStorage
    del NotEnoughEggsInStorage

if 'EggHardnessLevel' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.EggHardnessLevel = Ice.createTempClass()
    class EggHardnessLevel(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    EggHardnessLevel.SOFT = EggHardnessLevel("SOFT", 0)
    EggHardnessLevel.MEDIUM = EggHardnessLevel("MEDIUM", 1)
    EggHardnessLevel.HARD = EggHardnessLevel("HARD", 2)
    EggHardnessLevel._enumerators = { 0:EggHardnessLevel.SOFT, 1:EggHardnessLevel.MEDIUM, 2:EggHardnessLevel.HARD }

    _M_IntelligentHouse._t_EggHardnessLevel = IcePy.defineEnum('::IntelligentHouse::EggHardnessLevel', EggHardnessLevel, (), EggHardnessLevel._enumerators)

    _M_IntelligentHouse.EggHardnessLevel = EggHardnessLevel
    del EggHardnessLevel

if 'ScrambledEggsAdditionalIngredient' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.ScrambledEggsAdditionalIngredient = Ice.createTempClass()
    class ScrambledEggsAdditionalIngredient(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    ScrambledEggsAdditionalIngredient.PEPPER = ScrambledEggsAdditionalIngredient("PEPPER", 0)
    ScrambledEggsAdditionalIngredient.ONION = ScrambledEggsAdditionalIngredient("ONION", 1)
    ScrambledEggsAdditionalIngredient.CHIVES = ScrambledEggsAdditionalIngredient("CHIVES", 2)
    ScrambledEggsAdditionalIngredient.TOMATO = ScrambledEggsAdditionalIngredient("TOMATO", 3)
    ScrambledEggsAdditionalIngredient.MUSHROOMS = ScrambledEggsAdditionalIngredient("MUSHROOMS", 4)
    ScrambledEggsAdditionalIngredient._enumerators = { 0:ScrambledEggsAdditionalIngredient.PEPPER, 1:ScrambledEggsAdditionalIngredient.ONION, 2:ScrambledEggsAdditionalIngredient.CHIVES, 3:ScrambledEggsAdditionalIngredient.TOMATO, 4:ScrambledEggsAdditionalIngredient.MUSHROOMS }

    _M_IntelligentHouse._t_ScrambledEggsAdditionalIngredient = IcePy.defineEnum('::IntelligentHouse::ScrambledEggsAdditionalIngredient', ScrambledEggsAdditionalIngredient, (), ScrambledEggsAdditionalIngredient._enumerators)

    _M_IntelligentHouse.ScrambledEggsAdditionalIngredient = ScrambledEggsAdditionalIngredient
    del ScrambledEggsAdditionalIngredient

if '_t_ScrambledEggsAdditionalIngredientsSequence' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse._t_ScrambledEggsAdditionalIngredientsSequence = IcePy.defineSequence('::IntelligentHouse::ScrambledEggsAdditionalIngredientsSequence', (), _M_IntelligentHouse._t_ScrambledEggsAdditionalIngredient)

_M_IntelligentHouse._t_ScrambledEggsMaker = IcePy.defineValue('::IntelligentHouse::ScrambledEggsMaker', Ice.Value, -1, (), False, True, None, ())

if 'ScrambledEggsMakerPrx' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.ScrambledEggsMakerPrx = Ice.createTempClass()
    class ScrambledEggsMakerPrx(_M_IntelligentHouse.EggsMachinePrx):

        def prepareScrambledEggs(self, eggsAmount, hardnessLevel, additionalIngredients, context=None):
            return _M_IntelligentHouse.ScrambledEggsMaker._op_prepareScrambledEggs.invoke(self, ((eggsAmount, hardnessLevel, additionalIngredients), context))

        def prepareScrambledEggsAsync(self, eggsAmount, hardnessLevel, additionalIngredients, context=None):
            return _M_IntelligentHouse.ScrambledEggsMaker._op_prepareScrambledEggs.invokeAsync(self, ((eggsAmount, hardnessLevel, additionalIngredients), context))

        def begin_prepareScrambledEggs(self, eggsAmount, hardnessLevel, additionalIngredients, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.ScrambledEggsMaker._op_prepareScrambledEggs.begin(self, ((eggsAmount, hardnessLevel, additionalIngredients), _response, _ex, _sent, context))

        def end_prepareScrambledEggs(self, _r):
            return _M_IntelligentHouse.ScrambledEggsMaker._op_prepareScrambledEggs.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IntelligentHouse.ScrambledEggsMakerPrx.ice_checkedCast(proxy, '::IntelligentHouse::ScrambledEggsMaker', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IntelligentHouse.ScrambledEggsMakerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::ScrambledEggsMaker'
    _M_IntelligentHouse._t_ScrambledEggsMakerPrx = IcePy.defineProxy('::IntelligentHouse::ScrambledEggsMaker', ScrambledEggsMakerPrx)

    _M_IntelligentHouse.ScrambledEggsMakerPrx = ScrambledEggsMakerPrx
    del ScrambledEggsMakerPrx

    _M_IntelligentHouse.ScrambledEggsMaker = Ice.createTempClass()
    class ScrambledEggsMaker(_M_IntelligentHouse.EggsMachine):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IntelligentHouse::EggsMachine', '::IntelligentHouse::FoodPreparer', '::IntelligentHouse::ScrambledEggsMaker')

        def ice_id(self, current=None):
            return '::IntelligentHouse::ScrambledEggsMaker'

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::ScrambledEggsMaker'

        def prepareScrambledEggs(self, eggsAmount, hardnessLevel, additionalIngredients, current=None):
            raise NotImplementedError("servant method 'prepareScrambledEggs' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IntelligentHouse._t_ScrambledEggsMakerDisp)

        __repr__ = __str__

    _M_IntelligentHouse._t_ScrambledEggsMakerDisp = IcePy.defineClass('::IntelligentHouse::ScrambledEggsMaker', ScrambledEggsMaker, (), None, (_M_IntelligentHouse._t_EggsMachineDisp,))
    ScrambledEggsMaker._ice_type = _M_IntelligentHouse._t_ScrambledEggsMakerDisp

    ScrambledEggsMaker._op_prepareScrambledEggs = IcePy.Operation('prepareScrambledEggs', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), _M_IntelligentHouse._t_EggHardnessLevel, False, 0), ((), _M_IntelligentHouse._t_ScrambledEggsAdditionalIngredientsSequence, False, 0)), (), None, (_M_IntelligentHouse._t_NotEnoughEggsInStorage, _M_IntelligentHouse._t_CookingAlreadyInProgress))

    _M_IntelligentHouse.ScrambledEggsMaker = ScrambledEggsMaker
    del ScrambledEggsMaker

_M_IntelligentHouse._t_EggsBoiler = IcePy.defineValue('::IntelligentHouse::EggsBoiler', Ice.Value, -1, (), False, True, None, ())

if 'EggsBoilerPrx' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.EggsBoilerPrx = Ice.createTempClass()
    class EggsBoilerPrx(_M_IntelligentHouse.EggsMachinePrx):

        def boilEggs(self, eggsAmount, hardnessLevel, context=None):
            return _M_IntelligentHouse.EggsBoiler._op_boilEggs.invoke(self, ((eggsAmount, hardnessLevel), context))

        def boilEggsAsync(self, eggsAmount, hardnessLevel, context=None):
            return _M_IntelligentHouse.EggsBoiler._op_boilEggs.invokeAsync(self, ((eggsAmount, hardnessLevel), context))

        def begin_boilEggs(self, eggsAmount, hardnessLevel, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.EggsBoiler._op_boilEggs.begin(self, ((eggsAmount, hardnessLevel), _response, _ex, _sent, context))

        def end_boilEggs(self, _r):
            return _M_IntelligentHouse.EggsBoiler._op_boilEggs.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IntelligentHouse.EggsBoilerPrx.ice_checkedCast(proxy, '::IntelligentHouse::EggsBoiler', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IntelligentHouse.EggsBoilerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::EggsBoiler'
    _M_IntelligentHouse._t_EggsBoilerPrx = IcePy.defineProxy('::IntelligentHouse::EggsBoiler', EggsBoilerPrx)

    _M_IntelligentHouse.EggsBoilerPrx = EggsBoilerPrx
    del EggsBoilerPrx

    _M_IntelligentHouse.EggsBoiler = Ice.createTempClass()
    class EggsBoiler(_M_IntelligentHouse.EggsMachine):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IntelligentHouse::EggsBoiler', '::IntelligentHouse::EggsMachine', '::IntelligentHouse::FoodPreparer')

        def ice_id(self, current=None):
            return '::IntelligentHouse::EggsBoiler'

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::EggsBoiler'

        def boilEggs(self, eggsAmount, hardnessLevel, current=None):
            raise NotImplementedError("servant method 'boilEggs' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IntelligentHouse._t_EggsBoilerDisp)

        __repr__ = __str__

    _M_IntelligentHouse._t_EggsBoilerDisp = IcePy.defineClass('::IntelligentHouse::EggsBoiler', EggsBoiler, (), None, (_M_IntelligentHouse._t_EggsMachineDisp,))
    EggsBoiler._ice_type = _M_IntelligentHouse._t_EggsBoilerDisp

    EggsBoiler._op_boilEggs = IcePy.Operation('boilEggs', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), _M_IntelligentHouse._t_EggHardnessLevel, False, 0)), (), None, (_M_IntelligentHouse._t_NotEnoughEggsInStorage, _M_IntelligentHouse._t_CookingAlreadyInProgress))

    _M_IntelligentHouse.EggsBoiler = EggsBoiler
    del EggsBoiler

if 'TeaType' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.TeaType = Ice.createTempClass()
    class TeaType(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    TeaType.EARLGRAY = TeaType("EARLGRAY", 0)
    TeaType.OOLONG = TeaType("OOLONG", 1)
    TeaType.GUNPOWDER = TeaType("GUNPOWDER", 2)
    TeaType._enumerators = { 0:TeaType.EARLGRAY, 1:TeaType.OOLONG, 2:TeaType.GUNPOWDER }

    _M_IntelligentHouse._t_TeaType = IcePy.defineEnum('::IntelligentHouse::TeaType', TeaType, (), TeaType._enumerators)

    _M_IntelligentHouse.TeaType = TeaType
    del TeaType

_M_IntelligentHouse._t_TeaMaker = IcePy.defineValue('::IntelligentHouse::TeaMaker', Ice.Value, -1, (), False, True, None, ())

if 'TeaMakerPrx' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.TeaMakerPrx = Ice.createTempClass()
    class TeaMakerPrx(_M_IntelligentHouse.FoodPreparerPrx):

        def startMakingTea(self, type, context=None):
            return _M_IntelligentHouse.TeaMaker._op_startMakingTea.invoke(self, ((type, ), context))

        def startMakingTeaAsync(self, type, context=None):
            return _M_IntelligentHouse.TeaMaker._op_startMakingTea.invokeAsync(self, ((type, ), context))

        def begin_startMakingTea(self, type, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.TeaMaker._op_startMakingTea.begin(self, ((type, ), _response, _ex, _sent, context))

        def end_startMakingTea(self, _r):
            return _M_IntelligentHouse.TeaMaker._op_startMakingTea.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IntelligentHouse.TeaMakerPrx.ice_checkedCast(proxy, '::IntelligentHouse::TeaMaker', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IntelligentHouse.TeaMakerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::TeaMaker'
    _M_IntelligentHouse._t_TeaMakerPrx = IcePy.defineProxy('::IntelligentHouse::TeaMaker', TeaMakerPrx)

    _M_IntelligentHouse.TeaMakerPrx = TeaMakerPrx
    del TeaMakerPrx

    _M_IntelligentHouse.TeaMaker = Ice.createTempClass()
    class TeaMaker(_M_IntelligentHouse.FoodPreparer):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IntelligentHouse::FoodPreparer', '::IntelligentHouse::TeaMaker')

        def ice_id(self, current=None):
            return '::IntelligentHouse::TeaMaker'

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::TeaMaker'

        def startMakingTea(self, type, current=None):
            raise NotImplementedError("servant method 'startMakingTea' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IntelligentHouse._t_TeaMakerDisp)

        __repr__ = __str__

    _M_IntelligentHouse._t_TeaMakerDisp = IcePy.defineClass('::IntelligentHouse::TeaMaker', TeaMaker, (), None, (_M_IntelligentHouse._t_FoodPreparerDisp,))
    TeaMaker._ice_type = _M_IntelligentHouse._t_TeaMakerDisp

    TeaMaker._op_startMakingTea = IcePy.Operation('startMakingTea', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IntelligentHouse._t_TeaType, False, 0),), (), None, (_M_IntelligentHouse._t_CookingAlreadyInProgress,))

    _M_IntelligentHouse.TeaMaker = TeaMaker
    del TeaMaker

_M_IntelligentHouse._t_SittingDevice = IcePy.defineValue('::IntelligentHouse::SittingDevice', Ice.Value, -1, (), False, True, None, ())

if 'SittingDevicePrx' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.SittingDevicePrx = Ice.createTempClass()
    class SittingDevicePrx(Ice.ObjectPrx):

        def extend(self, context=None):
            return _M_IntelligentHouse.SittingDevice._op_extend.invoke(self, ((), context))

        def extendAsync(self, context=None):
            return _M_IntelligentHouse.SittingDevice._op_extend.invokeAsync(self, ((), context))

        def begin_extend(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.SittingDevice._op_extend.begin(self, ((), _response, _ex, _sent, context))

        def end_extend(self, _r):
            return _M_IntelligentHouse.SittingDevice._op_extend.end(self, _r)

        def contract(self, context=None):
            return _M_IntelligentHouse.SittingDevice._op_contract.invoke(self, ((), context))

        def contractAsync(self, context=None):
            return _M_IntelligentHouse.SittingDevice._op_contract.invokeAsync(self, ((), context))

        def begin_contract(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.SittingDevice._op_contract.begin(self, ((), _response, _ex, _sent, context))

        def end_contract(self, _r):
            return _M_IntelligentHouse.SittingDevice._op_contract.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IntelligentHouse.SittingDevicePrx.ice_checkedCast(proxy, '::IntelligentHouse::SittingDevice', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IntelligentHouse.SittingDevicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::SittingDevice'
    _M_IntelligentHouse._t_SittingDevicePrx = IcePy.defineProxy('::IntelligentHouse::SittingDevice', SittingDevicePrx)

    _M_IntelligentHouse.SittingDevicePrx = SittingDevicePrx
    del SittingDevicePrx

    _M_IntelligentHouse.SittingDevice = Ice.createTempClass()
    class SittingDevice(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IntelligentHouse::SittingDevice')

        def ice_id(self, current=None):
            return '::IntelligentHouse::SittingDevice'

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::SittingDevice'

        def extend(self, current=None):
            raise NotImplementedError("servant method 'extend' not implemented")

        def contract(self, current=None):
            raise NotImplementedError("servant method 'contract' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IntelligentHouse._t_SittingDeviceDisp)

        __repr__ = __str__

    _M_IntelligentHouse._t_SittingDeviceDisp = IcePy.defineClass('::IntelligentHouse::SittingDevice', SittingDevice, (), None, ())
    SittingDevice._ice_type = _M_IntelligentHouse._t_SittingDeviceDisp

    SittingDevice._op_extend = IcePy.Operation('extend', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    SittingDevice._op_contract = IcePy.Operation('contract', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_IntelligentHouse.SittingDevice = SittingDevice
    del SittingDevice

_M_IntelligentHouse._t_WarmArmchair = IcePy.defineValue('::IntelligentHouse::WarmArmchair', Ice.Value, -1, (), False, True, None, ())

if 'WarmArmchairPrx' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.WarmArmchairPrx = Ice.createTempClass()
    class WarmArmchairPrx(_M_IntelligentHouse.SittingDevicePrx):

        def setHeating(self, state, context=None):
            return _M_IntelligentHouse.WarmArmchair._op_setHeating.invoke(self, ((state, ), context))

        def setHeatingAsync(self, state, context=None):
            return _M_IntelligentHouse.WarmArmchair._op_setHeating.invokeAsync(self, ((state, ), context))

        def begin_setHeating(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.WarmArmchair._op_setHeating.begin(self, ((state, ), _response, _ex, _sent, context))

        def end_setHeating(self, _r):
            return _M_IntelligentHouse.WarmArmchair._op_setHeating.end(self, _r)

        def getHeating(self, context=None):
            return _M_IntelligentHouse.WarmArmchair._op_getHeating.invoke(self, ((), context))

        def getHeatingAsync(self, context=None):
            return _M_IntelligentHouse.WarmArmchair._op_getHeating.invokeAsync(self, ((), context))

        def begin_getHeating(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.WarmArmchair._op_getHeating.begin(self, ((), _response, _ex, _sent, context))

        def end_getHeating(self, _r):
            return _M_IntelligentHouse.WarmArmchair._op_getHeating.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IntelligentHouse.WarmArmchairPrx.ice_checkedCast(proxy, '::IntelligentHouse::WarmArmchair', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IntelligentHouse.WarmArmchairPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::WarmArmchair'
    _M_IntelligentHouse._t_WarmArmchairPrx = IcePy.defineProxy('::IntelligentHouse::WarmArmchair', WarmArmchairPrx)

    _M_IntelligentHouse.WarmArmchairPrx = WarmArmchairPrx
    del WarmArmchairPrx

    _M_IntelligentHouse.WarmArmchair = Ice.createTempClass()
    class WarmArmchair(_M_IntelligentHouse.SittingDevice):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IntelligentHouse::SittingDevice', '::IntelligentHouse::WarmArmchair')

        def ice_id(self, current=None):
            return '::IntelligentHouse::WarmArmchair'

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::WarmArmchair'

        def setHeating(self, state, current=None):
            raise NotImplementedError("servant method 'setHeating' not implemented")

        def getHeating(self, current=None):
            raise NotImplementedError("servant method 'getHeating' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IntelligentHouse._t_WarmArmchairDisp)

        __repr__ = __str__

    _M_IntelligentHouse._t_WarmArmchairDisp = IcePy.defineClass('::IntelligentHouse::WarmArmchair', WarmArmchair, (), None, (_M_IntelligentHouse._t_SittingDeviceDisp,))
    WarmArmchair._ice_type = _M_IntelligentHouse._t_WarmArmchairDisp

    WarmArmchair._op_setHeating = IcePy.Operation('setHeating', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_bool, False, 0),), (), None, ())
    WarmArmchair._op_getHeating = IcePy.Operation('getHeating', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_bool, False, 0), ())

    _M_IntelligentHouse.WarmArmchair = WarmArmchair
    del WarmArmchair

if 'PrincePoloStorageEmpty' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.PrincePoloStorageEmpty = Ice.createTempClass()
    class PrincePoloStorageEmpty(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IntelligentHouse::PrincePoloStorageEmpty'

    _M_IntelligentHouse._t_PrincePoloStorageEmpty = IcePy.defineException('::IntelligentHouse::PrincePoloStorageEmpty', PrincePoloStorageEmpty, (), False, None, ())
    PrincePoloStorageEmpty._ice_type = _M_IntelligentHouse._t_PrincePoloStorageEmpty

    _M_IntelligentHouse.PrincePoloStorageEmpty = PrincePoloStorageEmpty
    del PrincePoloStorageEmpty

_M_IntelligentHouse._t_PrincePoloSofa = IcePy.defineValue('::IntelligentHouse::PrincePoloSofa', Ice.Value, -1, (), False, True, None, ())

if 'PrincePoloSofaPrx' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.PrincePoloSofaPrx = Ice.createTempClass()
    class PrincePoloSofaPrx(_M_IntelligentHouse.SittingDevicePrx):

        def servePrincePolo(self, context=None):
            return _M_IntelligentHouse.PrincePoloSofa._op_servePrincePolo.invoke(self, ((), context))

        def servePrincePoloAsync(self, context=None):
            return _M_IntelligentHouse.PrincePoloSofa._op_servePrincePolo.invokeAsync(self, ((), context))

        def begin_servePrincePolo(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.PrincePoloSofa._op_servePrincePolo.begin(self, ((), _response, _ex, _sent, context))

        def end_servePrincePolo(self, _r):
            return _M_IntelligentHouse.PrincePoloSofa._op_servePrincePolo.end(self, _r)

        def princePoloAmountInStorage(self, context=None):
            return _M_IntelligentHouse.PrincePoloSofa._op_princePoloAmountInStorage.invoke(self, ((), context))

        def princePoloAmountInStorageAsync(self, context=None):
            return _M_IntelligentHouse.PrincePoloSofa._op_princePoloAmountInStorage.invokeAsync(self, ((), context))

        def begin_princePoloAmountInStorage(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.PrincePoloSofa._op_princePoloAmountInStorage.begin(self, ((), _response, _ex, _sent, context))

        def end_princePoloAmountInStorage(self, _r):
            return _M_IntelligentHouse.PrincePoloSofa._op_princePoloAmountInStorage.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IntelligentHouse.PrincePoloSofaPrx.ice_checkedCast(proxy, '::IntelligentHouse::PrincePoloSofa', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IntelligentHouse.PrincePoloSofaPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::PrincePoloSofa'
    _M_IntelligentHouse._t_PrincePoloSofaPrx = IcePy.defineProxy('::IntelligentHouse::PrincePoloSofa', PrincePoloSofaPrx)

    _M_IntelligentHouse.PrincePoloSofaPrx = PrincePoloSofaPrx
    del PrincePoloSofaPrx

    _M_IntelligentHouse.PrincePoloSofa = Ice.createTempClass()
    class PrincePoloSofa(_M_IntelligentHouse.SittingDevice):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IntelligentHouse::PrincePoloSofa', '::IntelligentHouse::SittingDevice')

        def ice_id(self, current=None):
            return '::IntelligentHouse::PrincePoloSofa'

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::PrincePoloSofa'

        def servePrincePolo(self, current=None):
            raise NotImplementedError("servant method 'servePrincePolo' not implemented")

        def princePoloAmountInStorage(self, current=None):
            raise NotImplementedError("servant method 'princePoloAmountInStorage' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IntelligentHouse._t_PrincePoloSofaDisp)

        __repr__ = __str__

    _M_IntelligentHouse._t_PrincePoloSofaDisp = IcePy.defineClass('::IntelligentHouse::PrincePoloSofa', PrincePoloSofa, (), None, (_M_IntelligentHouse._t_SittingDeviceDisp,))
    PrincePoloSofa._ice_type = _M_IntelligentHouse._t_PrincePoloSofaDisp

    PrincePoloSofa._op_servePrincePolo = IcePy.Operation('servePrincePolo', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_IntelligentHouse._t_PrincePoloStorageEmpty,))
    PrincePoloSofa._op_princePoloAmountInStorage = IcePy.Operation('princePoloAmountInStorage', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_int, False, 0), ())

    _M_IntelligentHouse.PrincePoloSofa = PrincePoloSofa
    del PrincePoloSofa

if 'BulBulIntensityNotInRange' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.BulBulIntensityNotInRange = Ice.createTempClass()
    class BulBulIntensityNotInRange(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::IntelligentHouse::BulBulIntensityNotInRange'

    _M_IntelligentHouse._t_BulBulIntensityNotInRange = IcePy.defineException('::IntelligentHouse::BulBulIntensityNotInRange', BulBulIntensityNotInRange, (), False, None, ())
    BulBulIntensityNotInRange._ice_type = _M_IntelligentHouse._t_BulBulIntensityNotInRange

    _M_IntelligentHouse.BulBulIntensityNotInRange = BulBulIntensityNotInRange
    del BulBulIntensityNotInRange

_M_IntelligentHouse._t_Bulbulator = IcePy.defineValue('::IntelligentHouse::Bulbulator', Ice.Value, -1, (), False, True, None, ())

if 'BulbulatorPrx' not in _M_IntelligentHouse.__dict__:
    _M_IntelligentHouse.BulbulatorPrx = Ice.createTempClass()
    class BulbulatorPrx(Ice.ObjectPrx):

        def setBulBulIntensity(self, intensity, context=None):
            return _M_IntelligentHouse.Bulbulator._op_setBulBulIntensity.invoke(self, ((intensity, ), context))

        def setBulBulIntensityAsync(self, intensity, context=None):
            return _M_IntelligentHouse.Bulbulator._op_setBulBulIntensity.invokeAsync(self, ((intensity, ), context))

        def begin_setBulBulIntensity(self, intensity, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.Bulbulator._op_setBulBulIntensity.begin(self, ((intensity, ), _response, _ex, _sent, context))

        def end_setBulBulIntensity(self, _r):
            return _M_IntelligentHouse.Bulbulator._op_setBulBulIntensity.end(self, _r)

        def getBulBulIntensity(self, context=None):
            return _M_IntelligentHouse.Bulbulator._op_getBulBulIntensity.invoke(self, ((), context))

        def getBulBulIntensityAsync(self, context=None):
            return _M_IntelligentHouse.Bulbulator._op_getBulBulIntensity.invokeAsync(self, ((), context))

        def begin_getBulBulIntensity(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.Bulbulator._op_getBulBulIntensity.begin(self, ((), _response, _ex, _sent, context))

        def end_getBulBulIntensity(self, _r):
            return _M_IntelligentHouse.Bulbulator._op_getBulBulIntensity.end(self, _r)

        def setActive(self, state, context=None):
            return _M_IntelligentHouse.Bulbulator._op_setActive.invoke(self, ((state, ), context))

        def setActiveAsync(self, state, context=None):
            return _M_IntelligentHouse.Bulbulator._op_setActive.invokeAsync(self, ((state, ), context))

        def begin_setActive(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.Bulbulator._op_setActive.begin(self, ((state, ), _response, _ex, _sent, context))

        def end_setActive(self, _r):
            return _M_IntelligentHouse.Bulbulator._op_setActive.end(self, _r)

        def getActive(self, context=None):
            return _M_IntelligentHouse.Bulbulator._op_getActive.invoke(self, ((), context))

        def getActiveAsync(self, context=None):
            return _M_IntelligentHouse.Bulbulator._op_getActive.invokeAsync(self, ((), context))

        def begin_getActive(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_IntelligentHouse.Bulbulator._op_getActive.begin(self, ((), _response, _ex, _sent, context))

        def end_getActive(self, _r):
            return _M_IntelligentHouse.Bulbulator._op_getActive.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_IntelligentHouse.BulbulatorPrx.ice_checkedCast(proxy, '::IntelligentHouse::Bulbulator', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_IntelligentHouse.BulbulatorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::Bulbulator'
    _M_IntelligentHouse._t_BulbulatorPrx = IcePy.defineProxy('::IntelligentHouse::Bulbulator', BulbulatorPrx)

    _M_IntelligentHouse.BulbulatorPrx = BulbulatorPrx
    del BulbulatorPrx

    _M_IntelligentHouse.Bulbulator = Ice.createTempClass()
    class Bulbulator(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::IntelligentHouse::Bulbulator')

        def ice_id(self, current=None):
            return '::IntelligentHouse::Bulbulator'

        @staticmethod
        def ice_staticId():
            return '::IntelligentHouse::Bulbulator'

        def setBulBulIntensity(self, intensity, current=None):
            raise NotImplementedError("servant method 'setBulBulIntensity' not implemented")

        def getBulBulIntensity(self, current=None):
            raise NotImplementedError("servant method 'getBulBulIntensity' not implemented")

        def setActive(self, state, current=None):
            raise NotImplementedError("servant method 'setActive' not implemented")

        def getActive(self, current=None):
            raise NotImplementedError("servant method 'getActive' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IntelligentHouse._t_BulbulatorDisp)

        __repr__ = __str__

    _M_IntelligentHouse._t_BulbulatorDisp = IcePy.defineClass('::IntelligentHouse::Bulbulator', Bulbulator, (), None, ())
    Bulbulator._ice_type = _M_IntelligentHouse._t_BulbulatorDisp

    Bulbulator._op_setBulBulIntensity = IcePy.Operation('setBulBulIntensity', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_float, False, 0),), (), None, (_M_IntelligentHouse._t_BulBulIntensityNotInRange,))
    Bulbulator._op_getBulBulIntensity = IcePy.Operation('getBulBulIntensity', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_float, False, 0), ())
    Bulbulator._op_setActive = IcePy.Operation('setActive', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_bool, False, 0),), (), None, ())
    Bulbulator._op_getActive = IcePy.Operation('getActive', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_bool, False, 0), ())

    _M_IntelligentHouse.Bulbulator = Bulbulator
    del Bulbulator

# End of module IntelligentHouse
